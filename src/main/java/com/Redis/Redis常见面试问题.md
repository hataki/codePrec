# redis常见面试问题

## 击穿

redis的key过期时间  且  一定是发生了高并发 ， 击穿了缓存层

LRU (Least recently used) 最近最少使用

LFU (Least frequently used) 最不经常使用

最终目的是：阻止高并发到达数据库，但是redis有没有命中的key；redis是单进程但实例的

setnx()  --> 设置锁

只有获得锁的 才可以访问到db ，其他的过滤掉

分布式锁 ---  设计问题 ：  死锁

比如第一个 锁住之后 ， 挂掉了

解决 给锁设置过期时间  ；

但是过期时间设置小（如1s），会导致锁没挂还没有释放，但还是超时了

|-- 解决： 多线程，一个线程监控db；一个监控锁





## 穿透

从业务接收到的查询是你的系统不存在的数据，这样一来就会直接跨过redis缓存去增加数据库压力

解决方案： 

**布隆过滤器**

- client端进行布隆过滤
- 算法放在后端，redis使用bitmap 过滤
- redis直接集成布隆

布隆缺点：只能增加不能删除（换布谷鸟，或者删除的key设置为null）



## 雪崩

类似于击穿（一个key，高并发请求，导致直接越过了redis访问到数据库）

大量的key同时失效，间接造成大量的访问到达数据库

随机（均匀）分布过期时间

需要分情况讨论：

某一时刻，需要大量的key过期并更新（如银行不同客户贷款利率，还息的数据）

***--- 强依赖击穿方案***

业务层加一层判断，零点延时

## 分布式锁

nx 设置过期时间

分布式锁使用zookeeper 更为强大

### API